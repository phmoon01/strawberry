---
title: "Stawberries "
author: MA615
date: 2024 Oct 14
format:
  html:
    embed-resources: true
editor: visual
---

# Strawberries: Data

This is a project about acquiring strawberry data from the USDA-NASS system and then cleaning, organizing, and exploring the data in preparation for data analysis. To get started, I acquired the data from the USDA NASS system and downloaded them in a csv.

## Data cleaning and organization references

["An introduction to data cleaning with R" by Edwin de Jonge and Mark van der Loo](https://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf)

["Problems, Methods, and Challenges in Comprehensive Data Cleansing" by Heiko MÃ¼ller and Johann-Christoph Freytag](https://www.researchgate.net/profile/Heiko-Mueller/publication/228929938_Problems_methods_and_challenges_in_comprehensive_data_cleansing/links/09e415101b58541e2c000000/Problems-methods-and-challenges-in-comprehensive-data-cleansing.pdf)

## Questions about Strawberries

-   Where they are grown? By whom?

-   Are they really loaded with carcinogenic poisons?

-   Are they really good for your health? Bad for your health?

-   Are organic strawberries carriers of deadly diseases?

-   When I go to the market should I buy conventional or organic strawberries?

-   Do Strawberry farmers make money?

-   How do the strawberries I buy get to my market?

## Strawberry data source and parameters

The data set for this assignment has been selected from:

\[[USDA_NASS_strawb_2024SEP25](https://quickstats.nass.usda.gov).

The data have been stored on NASS here: [USDA_NASS_strawb_2024SEP25](https://quickstats.nass.usda.gov/results/28141CE5-7429-36C3-A385-33ACC8030763) .

For the assignment, I stored the csv I downloaded on the MA615 Blackboard as strawberries25_v3.csv.

```{r}
#| label: load libraries and set options
#| warning: false
#| message: false
#| echo: false

library(knitr)  
library(kableExtra)
library(tidyverse)
library(magrittr)


```

```{r}
#| label: read data - glimpse 
#| echo: false

strawberry <- read_csv("strawberries25_v3.csv", col_names = TRUE, show_col_types = FALSE )

## glimpse(strawberry)
```

The data was originally collected at the county, state, and national levels, but the degree of missingness at the state level was too high, so I dropped the county-level data.

```{r}
#| label: ditch the counties
#| echo: false

# unique(strawberry$`Geo Level`)

strawberry <- strawberry |> 
  filter(`Geo Level`== "NATIONAL" | `Geo Level`== "STATE")
  

```

There are 5,359 rows and 21 column in the initial data set. The only complete year is 2022, although there is data for years 2018 through 2024.

To work with the data, define a function to remove columns with only single value in all its rows.

```{r}
#| label: function def - drop 1-item columns
#| echo: false

drop_one_value_col <- function(df, prt_val = FALSE){ 
 # browser()
  df_id <- ensym(df)
  if(prt_val){
  msg = paste("Looking for single value columns in data frame: ",as.character(df_id) )
  print(msg)}
  ## takes whole dataframe
dropc <- NULL
val <- NULL
## test each column for a single value
for(i in 1:dim(df)[2]){   
  if(dim(distinct(df[,i]))[1] == 1){
    dropc <- c(dropc, i)
    val <- c(val, df[1,i])
  }
} 

if(prt_val){
if(is.null(dropc)){
  print("No columns dropped")
  return(df)}else{
   print("Columns dropped:")
   # print(colnames(df)[drop])
   print(unlist(val))
   df <- df[, -1*dropc]
   return(df)
  }
}
 df <- df[, -1*dropc]
   return(df)
}


## use the function

strawberry <- strawberry |> drop_one_value_col(prt_val = FALSE)


```

To work with this data, split the Census data from the Survey data.

## Census data cleaning and organizing

we're examining census data because it's different from survey data

```{r}
#| label: srawberries split census, survey
#| echo: false


straw_cen <- strawberry |> filter(Program=="CENSUS")

straw_sur <- strawberry |> filter(Program=="SURVEY")

straw_cen <- straw_cen |> drop_one_value_col()

straw_sur <- straw_sur |> drop_one_value_col()

rm(strawberry)

```

```{r}
#| label: straw_cen split cols
#| echo: false

straw_cen <- straw_cen |>
  separate_wider_delim(  cols = `Data Item`,
                         delim = " - ",
                         names = c("strawberries",
                                 "Category"),
                         too_many = "error",
                         too_few = "align_start"
                       )

```

we're isolating organic data

```{r}
#| label: isolate organic
#| echo: false

# 
# unique(straw_cen$strawberries)
# straw_cen$strawberries |> str_which("STRAWBERRIES") |> length()
# straw_cen$strawberries |> str_which("STRAWBERRIES, ORGANIC") |> length()
# straw_cen$strawberries |> str_which("STRAWBERRIES, ORGANIC, FRESH MARKET") |> length()
# straw_cen$strawberries |> str_which("STRAWBERRIES, ORGANIC, PROCESSING" ) |> length()
# 
# ## count the cases
# straw_cen$strawberries |> str_which("ORGANIC") |> length()
# straw_cen$strawberries |> str_which("FRESH MARKET") |> length()
# straw_cen$strawberries |> str_which("PROCESSING") |> length()

straw_cen <- straw_cen |>
  separate_wider_delim(  cols = strawberries,
                         delim = ", ",
                         names = c("strawberries",
                                 "ORGANIC",
                                 "organic_detail"),
                         
                         too_many = "error",
                         too_few = "align_start"
                       )

straw_cen <- straw_cen |> drop_one_value_col()

## how many organic rows?

organic_cen <- straw_cen |> filter(ORGANIC == "ORGANIC")

## sum(is.na(straw_cen$ORGANIC))

straw_cen <- straw_cen[(is.na(straw_cen$ORGANIC)),]


straw_cen <- straw_cen |> drop_one_value_col()



```

Note that straw_cen has only one year: 2022

Current stats Census date has been isolated and split between Organic and Conventional strawberries

```{r}
#| label: explore straw_cen$Category
#| echo: false

straw_cen <- straw_cen |>
  separate_wider_delim(  cols = `Category`,
                         delim = " ",
                         names = c("COL1",
                                 "COL2"),
                         too_many = "merge",
                         too_few = "align_start"
                       )



straw_cen$COL2 <- str_replace(straw_cen$COL2, "WITH ", "")

straw_cen <- straw_cen |> rename(Measure = COL1, Bearing_type= COL2)

```

```{r}
#| label: explore straw_cen$Domain & Domain Category
#| echo: false


## remove AREA GROWN and parens 
## change NOT SPECIFIEC TO TOTAL

straw_cen <- straw_cen |> rename(size_bracket = `Domain Category`)

straw_cen$size_bracket <- str_replace(straw_cen$size_bracket, "NOT SPECIFIED", "TOTAL")

straw_cen$size_bracket <- str_replace(straw_cen$size_bracket, "AREA GROWN: ", "")

```

```{r}
#| label: explore organic_cen
#| echo: false

organic_cen <- organic_cen |> drop_one_value_col()



```

### imputed values

```{r}
#| label: imputation starts here
#| echo: false
#| warning: false
#| message: false



#Casting value to numeric and replacing commas with blanks first

straw_cen$Value <- as.numeric(str_replace(straw_cen$Value, ",", ""))

organic_cen$Value <- as.numeric(str_replace(organic_cen$Value, ",", ""))
```

```{r}
#| label: dim
#| echo: false


#Looking at what's missing in our strawberry_census dataframes

aa <- dim(straw_cen |> filter(is.na(Value)))
bb <- dim(organic_cen |> filter(is.na(Value)))
```

We'll start with missing value interpolation for census data:

```{r}
#| label: imputation final
#| echo: false

state_vec <- straw_cen |> distinct(State)

#Let's write a function that does the percentage imputation

#First retrieve the indices of the rows with NA Values:
bearing_na_indices <- which(is.na(straw_cen$Value) &
                              straw_cen$Bearing_type == "BEARING")
non_bearing_na_indices <- which(is.na(straw_cen$Value) &
                                  straw_cen$Bearing_type == "NON-BEARING")

#We will also need indices of the rows with NA Values that have bearing 'Grown'

grown_na_indices <- which(is.na(straw_cen$Value) &
                            straw_cen$Bearing_type == "GROWN")

rm(state_vec)

```

We will first interpolate the Bearing "Grown" values. Then we can interpolate Bearing and Non-bearing from those values as we discussed in lecture.

```{r}
#| label: function bearing_non_bearing_prop_avg
#| echo: false



bearing_non_bearing_prop_avg <- function(state, measure, bearing) {
  state_cen <- straw_cen |> filter(State == state & Measure == measure)
  bearing_vec <- state_cen |> filter(Bearing_type == bearing)
  bearing_vec <- bearing_vec$Value
  bearing_indices <- which(!is.na(bearing_vec))
  
  grown_vec <- state_cen |> filter(Bearing_type == "GROWN")
  grown_vec <- grown_vec[bearing_indices, ]$Value
  
  bearing_no_na <- which(!is.na(bearing_vec))
  grown_no_na <- which(!is.na(grown_vec))
  
  not_na_indices <- intersect(bearing_no_na, grown_no_na)
  
  bearing_vec_noNA <- bearing_vec[not_na_indices]
  grown_vec_noNA <- grown_vec[not_na_indices]
  
  return(mean(bearing_vec_noNA / grown_vec_noNA))
}

```

Now if GROWN is NA, there are three possibilities:

**1** Bearing and Non-bearing are both NA\
**2** Neither Bearing nor Non-bearing are NA\
**3** One of Bearing nor Non-bearing are NA

The solution for each of these cases is different:

**1** Interpolate from the total for area grown(a check of the dataframe shows you that the total is never NA). We'll try and calculate the average ratio of the missing parts across the non-missing data and split the difference from the total across those\
**2** Sum Bearing and non-bearing. Easy.

**3** Calculate the average proportion of grown that bearing or non bearing(as the case may be) is for the state in question. Then we use that to figure out the value.

```{r}
#| label: imput
#| echo: false

#We can deal with those cases as follows:
#We are going to write a function that does the imputation for one index
#Then we can just sapply it over the vector if na indices and finally
#assign that to the missing values.

#First we adapt our previous proportion function to size brackets as a prop of total
#This is a function we shall use below


prop_by_size_bracket <- function(state, measure, bearing, bracket) {
  state_cen <- straw_cen |> filter(State == state & Measure == measure)
  bracket_vec <- state_cen |> filter(size_bracket == bracket)
  bracket_vec <- bracket_vec$Value
  bracket_indices <- which(!is.na(bracket_vec))
  
  if (length(bracket_indices) != 0) {
    total_vec <- state_cen |> filter(size_bracket == "TOTAL")
    total_vec <- total_vec[bracket_indices, ]$Value
    
    bracket_no_na <- which(!is.na(bracket_vec))
    total_no_na <- which(!is.na(total_vec))
    
    if (length(intersect(bracket_no_na, total_no_na)) != 0) {
      not_na_indices <- intersect(bracket_no_na, total_no_na)
      
      bracket_vec_noNA <- bracket_vec[not_na_indices]
      total_vec_noNA <- total_vec[not_na_indices]
      
    } else{
      bracket_vec_noNA <- mean(bracket_vec[bracket_no_na])
      total_vec_noNA <- mean(total_vec[total_no_na])
    }
    return(mean(bracket_vec_noNA / total_vec_noNA))
  } else{
    sum_non_total <- state_cen |> filter(size_bracket != "TOTAL") |> filter(!is.na(Value))
    sum_non_total <- sum(sum_non_total$Value)
    
    total <- state_cen |> filter(size_bracket == "TOTAL")
    total <- sum(total$Value)
    #There's a small technicality to deal with here:
    #The rest of this function is returning a proportion but this part is not.
    #It gives us the actual imputed value.
    #That's fine but we need to be careful how we use it in the final function
    #To do that, we'll return a vector with an arbitrary second element
    #Then we can check the type when we call this function and use it accordingly
    return(as.character((total - sum_non_total) / length(bracket_vec)))
    
  }
  
}




census_grown_imputer <- function(i) {
  state <- as.character(straw_cen[i, "State"])
  measure <- as.character(straw_cen[i, "Measure"])
  size_brack <- as.character(straw_cen[i, "size_bracket"])
  
  non_bearing_val <- as.numeric(
    straw_cen |> filter(
      State == state &
        Measure ==   measure &
        size_bracket == size_brack &
        Bearing_type == "NON-BEARING"
    ) |> select(Value)
  )
  
  bearing_val <- as.numeric(
    straw_cen |> filter(
      State == state &
        Measure ==   measure &
        size_bracket == size_brack &
        Bearing_type == "BEARING"
    ) |> select(Value)
  )
  
  #Starting with case 2 because its the easiest
  if (!is.na(non_bearing_val) & !is.na(bearing_val)) {
    return(bearing_val + non_bearing_val)
    
  } else if ((!is.na(non_bearing_val) & is.na(bearing_val))) {
    #Case 3 and non-bearing is not na
    prop <- bearing_non_bearing_prop_avg(state, measure, bearing = "NON-BEARING")
    return(non_bearing_val / prop)
    
  } else if ((!is.na(bearing_val) & is.na(non_bearing_val))) {
    #case 3 and bearing is not na
    prop <- bearing_non_bearing_prop_avg(state, measure, bearing = "BEARING")
    return(bearing_val / prop)
    
  } else{
    #Both bearing and non-bearing are NA
    bearing <- "GROWN"
    prop <- prop_by_size_bracket(state, measure, bearing, size_brack)
    total <- as.numeric(
      straw_cen |> filter(
        State == state &
          Measure == measure &
          size_bracket == "TOTAL" & Bearing_type == bearing
      ) |> select(Value)
    )
    if (class(prop) == "character") {
      return(as.numeric(prop))
    } else{
      return(prop * total)
    }
  }
}

```

Applying our functions now to strawberry census:

```{r}
#| label: using the functions
#| echo: false

grown_imputed <- sapply(grown_na_indices, census_grown_imputer)
straw_cen$Value[grown_na_indices] <- grown_imputed

```

Now that we have imputed the values, we still have an adjustment to make. Because we are using proportional averages, the values might no longer add up to our totals. So we need to write a function that will scale our imputed values so that the totals add up.

The happy news is because we are doing this by index, we still know which are the values we have imputed and therefore which values we need to scale.

```{r}
#| label: state_index_range_retriever
#| echo: false


state_index_range_retriever <- function(state, bearing, measure) {
  return(
    which(
      straw_cen$State == state &
        straw_cen$Measure == measure & straw_cen$Bearing_type == bearing
    )
  )
}
#We're going to
imputed_val_scaler <- function(index_vec, bearing) {
  scaled_imputed_vals <- rep(0, length(index_vec))
  #First, we group the indices which have the same state, bearing
  #Keep track of indices we've already grouped
  index_tracker <- c()
  for (i in index_vec) {
    if (!(i %in% index_tracker)) {
      grouped_indices <- index_vec[which(straw_cen$State[index_vec] == straw_cen$State[i])]
      #Then we scale those indices to the total:
      state <- straw_cen$State[i]
      measure <- straw_cen$Measure[i]
      state_total_cen <- straw_cen |> filter(State == state &
                                               Measure == measure & Bearing_type == bearing)
      
      #This is so we can sum over non-totals
      state_total_cen_not_total <- state_total_cen |> filter(Domain != "TOTAL")
      
      #Extract the total we want everything to sum to
      overall_total <- state_total_cen |> filter(Domain == "TOTAL")
      overall_total <- overall_total$Value
      
      #What is the correct sum the imputed values should add to?
      grouped_indices_adj <- grouped_indices - which(
        straw_cen$State == state &
          straw_cen$Measure == measure & straw_cen$Bearing_type == bearing
      )[1] + 1
      correct_total <- overall_total - sum(state_total_cen_not_total$Value[-grouped_indices_adj])
      incorrect_total <- sum(state_total_cen_not_total$Value[grouped_indices_adj])
      #Now we scale these:
      scaled_vals <- (correct_total / incorrect_total) * state_total_cen_not_total$Value[grouped_indices_adj]
      scaled_imputed_vals[which(index_vec %in% grouped_indices)] <- scaled_vals
      index_tracker <- c(grouped_indices, index_tracker)
    }
  }
  
  return(scaled_imputed_vals)
  
}

grown_imputed_scaled <- imputed_val_scaler(grown_na_indices, bearing = "GROWN")
straw_cen$Value[grown_na_indices] <- grown_imputed_scaled

```

### Imputing acres bearing and non-bearing

```{r}
#| label: Imputing acres bearing and non-bearing
#| echo: false

bearing_non_bearing_prop_avg<-function(i){
  state<-as.character(straw_cen[i,"State"])
  measure<-as.character(straw_cen[i,"Measure"])
  bearing<-as.character(straw_cen[i,"Bearing_type"])
  
  #Filter and retrieve the 
  state_cen<-straw_cen |> filter(State==state& Measure==measure)
  bearing_vec<-state_cen |> filter(Bearing_type==bearing)
  bearing_vec<-bearing_vec$Value
  bearing_indices<-which(!is.na(bearing_vec))
  
  grown_vec<-state_cen |> filter(Bearing_type==bearing)
  grown_vec<-grown_vec[bearing_indices,]$Value
  
  bearing_no_na<-which(!is.na(bearing_vec))
  grown_no_na<-which(!is.na(grown_vec))
  
  not_na_indices<-intersect(bearing_no_na,grown_no_na)
  
  bearing_vec_noNA<-bearing_vec[not_na_indices]
  grown_vec_noNA<-grown_vec[not_na_indices]
  
  return(mean(bearing_vec_noNA/grown_vec_noNA))
}


```

```{r}
#| label: bearing_imputed calculated
#| echo: false


bearing<-"BEARING"
bearing_imputed <-sapply(bearing_na_indices,bearing_non_bearing_prop_avg)
straw_cen$Value[bearing_na_indices]<-bearing_imputed


bearing<-"NON-BEARING"
non_bearing_imputed <-sapply(non_bearing_na_indices,bearing_non_bearing_prop_avg)
straw_cen$Value[non_bearing_na_indices]<-non_bearing_imputed


```

We can go one better with imputation where we impute case 1 for the "GROWN" categories together with other case 1s for each. A slight modification to the function above plus some other changes achieves this.

CENSUS TABLES

## Survey data cleaning and organizing

```{r}
#| label: Survey data starts here
#| echo: false

## Data Item

## unique(straw_sur$`Data Item`)

straw_sur1 <- straw_sur |>  separate_wider_delim(cols = `Data Item`,
                                                delim = ", ",
                                                names = c("straw",
                                                         "mkt",
                                                         "measure",
                                                         "other"
                                                         ),
                                                too_many = "merge",
                                                too_few = "align_start")
                                                
                                                  
straw_sur2 <- straw_sur1 |> separate_wider_delim(cols = "straw", 
                                                 delim = " - ",
                                                 names = c("straw",
                                                           "more"),
                                                 too_many = "merge",
                                                 too_few = "align_start"
                                                 )
  

rm(straw_sur, straw_sur1)

```

Shift data into alignment function

```{r}
#| label: function shift_loc() Shift data on a row
#| echo: false

## function shift_loc
## Moves adjacent data cells in a data.frame on a single row
## Use this function to fix alignment problems after separating 
## columns containing multiple columns of data. 

## Of course the working assumption is that there is room in the 
## data frame for the data you're shifting.
##
## The data cells that are empty after the data shift are NA.
## 
## Input paramaters
## 
## df -- data frame
## col_name -- name of colume where the left-most data item is located
## dat_name -- name of data item in the column
## num_col -- the number of columns is the same as the number of
##            adjacent data to be moved.
## num_shift -- the number of rows to move the data 
##


shift_loc <- function(df, col_name, dat_name, num_col, num_shift){
 # browser()
  col_num = which(colnames(df) == col_name)
  row_num = which(df[,col_num] == dat_name)  ## calcs a vector of rows
  
  for(k in 1:length(row_num)){
  d = rep(0,num_col) ## storage for items to be moved
  for(i in 1:num_col){
    d[i] = df[row_num[k], col_num + i - 1]
  }
  for(i in 1:num_col){
    ra = row_num[k]
    cb = col_num + i - 1
    df[ra, cb] <-  NA
  }
  for(j in 1:num_col){
    rc = row_num[k]
    cd = col_num + j - 1 + num_shift
    df[rc, cd] = d[j]
  }
  }
 # sprintf("Rows adjusted:")
  # print("%d",row_num)
  return(df)
}

```

```{r}
#| label: use shift_loc() to align columns
#| echo: false


straw_sur2 %<>% shift_loc("more", "PRICE RECEIVED", 2, 1 )

straw_sur2 %<>% shift_loc("more", "ACRES HARVESTED", 1, 1 )

straw_sur2 %<>% shift_loc("more", "ACRES PLANTED", 1, 1 )

straw_sur2 %<>% shift_loc("more", "PRODUCTION", 2, 1 )

straw_sur2 %<>% shift_loc("more", "YIELD", 2, 1 )

straw_sur2 %<>% shift_loc("more", "APPLICATIONS", 3, 1 )

straw_sur2 %<>% shift_loc("more", "TREATED", 3, 1 )

straw_sur2 %<>% drop_one_value_col()


```

Examine Domain

```{r}
#| label: split domain column into chem, fert, total data frames
#| echo: false

# unique(straw_sur2$Domain)
#    The Domain column (2965 rows) contains data about
#    Chemicals (3359 rows)
#    Fertilizers (115 rows)
#    Production and Yield data ("TOTAL") (491 rows)
#

#    The Chemical data is in categories for 
#         Insecticides
#         Fungicides
#         Herbicdes, and
#         Other
#

#    The Domain is split into three dataframes for
#     "Total", "Chemical", and "Fertilizer"


straw_sur2 <- straw_sur2 |>  
  separate_wider_delim(cols = Domain,
                      delim = ", ",
                      names = c("col1",
                                "col2"),
                                                
                      too_many = "merge",
                      too_few = "align_start")


# unique(straw_sur2$col1)

survey_d_total <- straw_sur2 |>  filter(col1 == "TOTAL")

survey_d_chem <- straw_sur2 |>  filter(col1 == "CHEMICAL")

survey_d_fert <- straw_sur2 |>  filter(col1 == "FERTILIZER")


```

now look at totals

```{r}
#| label: align columns
#| echo: false

survey_d_total %<>% drop_one_value_col()

### align terms

survey_d_total %<>% shift_loc("measure", "MEASURED IN $ / CWT", 1, 1 )


survey_d_total %<>% shift_loc("measure", "MEASURED IN $", 1, 1 )


survey_d_total %<>% shift_loc("measure", "MEASURED IN CWT", 1, 1 )

survey_d_total %<>% shift_loc("measure", "MEASURED IN TONS", 1, 1 )


survey_d_total %<>% shift_loc("measure", "MEASURED IN CWT / ACRE", 1, 1 )

survey_d_total %<>% shift_loc("measure", "MEASURED IN TONS / ACRE", 1, 1 )


#### split the mkt column


survey_d_total <- survey_d_total |>  
  separate_wider_delim(cols = mkt,
                      delim = " - ",
                      names = c("col3",
                                "col4"),
                   too_many = "merge",
                    too_few = "align_start")

```

there are two markets for Strawberries -- Fresh Marketing and Processing

make a table for each

from the Survey Totals

we have reports for

Markets: Fresh and Processing Operations: Growing and Production

```{r}
#| label: markets
#| echo: false

survey_d_total %<>%
  select(-`State ANSI`)

survey_d_total <- survey_d_total |> 
  group_by(Year) |> 
  group_by(State) |>
  group_by(Period) |>
  group_by(col3)



# unique(survey_d_total$col3)
# unique(survey_d_total$col4)

# mv <- survey_d_total |> filter(col3=="PRODUCTION") |> count()
# mv1 <- which(survey_d_total$col3 == "PRODUCTION") 
# mv2 <- is.na(survey_d_total$col4[mv1])
# sum(mv2) == length(mv1)

survey_d_total <-  survey_d_total |>
  shift_loc(col_name = "col3", dat_name = "PRODUCTION", 2, 1)

# mv1 <- which(survey_d_total$col3 == "PRICE RECEIVED") 
# mv2 <- is.na(survey_d_total$col4[mv1])
# sum(mv2) == length(mv1)


survey_d_total <-  survey_d_total |>
  shift_loc(col_name = "col3", 
            dat_name = "PRICE RECEIVED", 2, 1)

survey_d_total <-  survey_d_total |>
  rename(market = col3, product_price = col4, summ = measure, measure = other)


## fix ACRES HARVESTED 
## the category "HARVESTED" and its measure "acRES" are in reverse
## order

h_index <- which(str_detect(survey_d_total$market, "ACRES HARVESTED") == TRUE)
survey_d_total$product_price[h_index] <- "HARVESTED"
survey_d_total$measure[h_index] <- "acres"
survey_d_total$market[h_index] <- NA

## fix ACRES PLANTED
p_index <- which(str_detect(survey_d_total$market, "ACRES PLANTED") == TRUE)
survey_d_total$product_price[p_index] <- "PLANTED"
survey_d_total$measure[p_index] <- "Acres"
survey_d_total$market[p_index] <- NA

## fixed up measure column
survey_d_total$measure <- str_replace(survey_d_total$measure, "MEASURED IN ", "")

## Other table fix-ups
## move Yield

y_index <- which(str_detect(survey_d_total$market, "YIELD") == TRUE)
survey_d_total$product_price[y_index] <- "YIELD"
survey_d_total$market[y_index] <- NA

ns_index <- which(str_detect(survey_d_total$market, "NOT SOLD") == TRUE)
survey_d_total$product_price[ns_index] <- "NOT SOLD"
survey_d_total$market[ns_index] <- NA

u_index <- which(str_detect(survey_d_total$market, "UTILIZED") == TRUE)
survey_d_total$product_price[u_index] <- "UTILIZED"
survey_d_total$market[u_index] <- NA

rm(ns_index, p_index, u_index, y_index, h_index, straw_sur2)

```

```{r}
#| label: make state-wise DFs
#| echo: false


# unique(survey_d_total$State)
# [1] "US TOTAL"       "CALIFORNIA"    
# [3] "FLORIDA"        "OTHER STATES"  
# [5] "NEW YORK"       "NORTH CAROLINA"
# [7] "OREGON"         "WASHINGTON"  


sur_tot_ca <- survey_d_total |> 
  filter(State == "CALIFORNIA")

sur_tot_fl <- survey_d_total |> 
  filter(State == "FLORIDA")

sur_tot_ny <- survey_d_total |> 
  filter(State == "NEW YORK")

sur_tot_or <- survey_d_total |> 
  filter(State == "OREGON")

sur_tot_nc <- survey_d_total |> 
  filter(State == "NORTH CAROLINA")

sur_tot_wa <- survey_d_total |> 
  filter(State == "WASHINGTON")

sur_tot_other <- survey_d_total |> 
  filter(State == "OTHER STATES")

sur_tot_US <- survey_d_total |> 
  filter(State == "US TOTAL")

```

### Florida - California - 2018 -2023

```{r}
#| label: FL CA by year
#| echo: false
 
sur_CA_23 <- sur_tot_ca |> filter(Year == "2023") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")


sur_fl_23 <- sur_tot_fl |> filter(Year == "2023") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_CA_22 <- sur_tot_ca |> filter(Year == "2022") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_fl_22 <- sur_tot_fl |> filter(Year == "2022") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_CA_21 <- sur_tot_ca |> filter(Year == "2021") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_fl_21 <- sur_tot_fl |> filter(Year == "2021") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_CA_20 <- sur_tot_ca |> filter(Year == "2020") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")


sur_fl_20 <- sur_tot_fl |> filter(Year == "2020") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

sur_CA_19 <- sur_tot_ca |> filter(Year == "2019") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")


sur_fl_19 <- sur_tot_fl |> filter(Year == "2019") |>
  select(market, product_price, summ, measure, Value) |>
   filter(Value != "(D)")

# sur_CA_18 <- sur_tot_ca |> filter(Year == "2018") |>
#   select(market, product_price, summ, measure, Value) |>
#    filter(Value != "(D)")
# 
# 
# sur_fl_18 <- sur_tot_fl |> filter(Year == "2018") |>
#   select(market, product_price, summ, measure, Value) |>
#    filter(Value != "(D)")

sur_fl_19 <- sur_fl_19 |> drop_one_value_col()
sur_fl_20 <- sur_fl_20 |> drop_one_value_col()
sur_fl_21 <- sur_fl_21 |> drop_one_value_col()
sur_fl_22 <- sur_fl_22 |> drop_one_value_col()
sur_fl_23 <- sur_fl_23 |> drop_one_value_col()

sur_CA_23 <- sur_CA_23 |> drop_one_value_col()
sur_CA_22 <- sur_CA_22 |> drop_one_value_col()
sur_CA_21 <- sur_CA_21 |> drop_one_value_col()
sur_CA_20 <- sur_CA_20 |> drop_one_value_col()
sur_CA_19 <- sur_CA_19 |> drop_one_value_col()

sur_CA_19 <- sur_CA_19 |> rename(value_19 = Value)
sur_CA_20 <- sur_CA_20 |> rename(value_20 = Value)
sur_CA_21 <- sur_CA_21 |> rename(value_21 = Value)
sur_CA_22 <- sur_CA_22 |> rename(value_22 = Value)
sur_CA_23 <- sur_CA_23 |> rename(value_23 = Value)

sur_CA_19_23 <- cbind(sur_CA_19,sur_CA_20[,3],sur_CA_21[,3],sur_CA_22[,3],sur_CA_23[,3])

sur_fl_19 <- sur_fl_19 |> rename(value_19 = Value)
sur_fl_20 <- sur_fl_20 |> rename(value_20 = Value)
sur_fl_21 <- sur_fl_21 |> rename(value_21 = Value)
sur_fl_22 <- sur_fl_22 |> rename(value_22 = Value)
sur_fl_23 <- sur_fl_23 |> rename(value_23 = Value)

sur_fl_19_23 <- cbind(sur_fl_19,sur_fl_20[,3],sur_fl_21[,3],sur_fl_22[,3],sur_fl_23[,3])

```

```{r}
#| label: survey_totals tables
#| echo: false

library(knitr)
library(kableExtra)

fl_19_23 <- as.data.frame(sur_fl_19_23)

colnames(fl_19_23) <- c("Measure", "Units", "2019", "2020", "2021", "2022", "2023")



fl_19_23$Measure <- c("Price", "Havested", "Planted", "Production", "Production", "Yield", "Not Sold", "Utilized")

fl_19_23 <- fl_19_23 |> select(-Units)

Units <- c("$-cwt", "ac", "ac", "$", "cwt", "cwt-ac", "cwt", "cwt")

fl_19_23 <- fl_19_23 |> mutate(Units, .after=Measure)



#fl |> kable()

```

### California and Florida chemicals

```{r}
#| label: chemicals
#| echo: false

survey_d_chem <- survey_d_chem |> drop_one_value_col()

survey_d_chem <- survey_d_chem |> select(-`State ANSI`)

## California Chemicals

# ca_chem <- survey_d_chem |> filter(State=="CALIFORNIA") |>
#   select()

survey_d_chem <- survey_d_chem |>  
  separate_wider_delim(cols = mkt,
                      delim = " - ",
                      names = c("mk1",
                                "mk2"),
                   too_many = "merge",
                    too_few = "align_start")
                

survey_d_chem$measure <- str_replace(survey_d_chem$measure, "MEASURED IN ", "")

# unique(survey_d_chem$`Domain Category`)

survey_d_chem$`Domain Category` <- str_replace(survey_d_chem$`Domain Category`, "CHEMICAL, ", "")

survey_d_chem <- survey_d_chem |> rename(chem = `Domain Category`)

survey_d_chem <- survey_d_chem |>
          separate_wider_delim(cols = chem,
                              delim = ": ",
                              names = c("type",
                                "chem_type"),
                           too_many = "merge",
                            too_few = "align_start")

  # s1 <- survey_d_chem$col2 == survey_d_chem$type
  # sum(s1)

  survey_d_chem <- survey_d_chem |> select(-col2)
  
  survey_d_chem <- survey_d_chem |> 
    rename(chem_name = chem_type)
  
  survey_d_chem$chem_name <- str_replace(survey_d_chem$chem_name, "^\\(", "")
  
   survey_d_chem$chem_name <- str_replace(survey_d_chem$chem_name, "\\)$", "")
  
survey_d_chem <- survey_d_chem |>  
  separate_wider_delim(cols = chem_name,
                      delim = " = ",
                      names = c("chem_name",
                                "chem_index"),
                   too_many = "error",
                    too_few = "align_start")

chemicals_Used_cA <- survey_d_chem |> 
  filter(State == "CALIFORNIA") |>
  select(type, chem_name, chem_index)
 
cA_chem_fung <- chemicals_Used_cA |>   
  filter(type == "FUNGICIDE") |> 
  distinct()
  

cA_chem_herb <- chemicals_Used_cA |>   
  filter(type == "HERBICIDE") |>
  distinct()


cA_chem_insect <- chemicals_Used_cA |>   
  filter(type == "INSECTICIDE") |>
  distinct()

cA_chem_other <- chemicals_Used_cA |>   
  filter(type == "OTHER") |>
  distinct()




```

### California and Florida fertilizers

```{r}
#| label: fertilizer
#| echo: false

survey_d_fert <- survey_d_fert |> drop_one_value_col()

survey_d_fert <- survey_d_fert |> select(-`State ANSI`)

survey_d_fert <- survey_d_fert |>  
  separate_wider_delim(cols = mkt,
                      delim = " - ",
                      names = c("mk1",
                                "mk2"),
                   too_many = "merge",
                    too_few = "align_start")
                
survey_d_fert$measure <- str_replace(survey_d_fert$measure, "MEASURED IN ", "")

# unique(survey_d_chem$`Domain Category`)

survey_d_fert$`Domain Category` <- str_replace(survey_d_fert$`Domain Category`, "CHEMICAL, ", "")

survey_d_fert <- survey_d_fert |> rename(chem = `Domain Category`)

survey_d_fert <- survey_d_fert |>
          separate_wider_delim(cols = chem,
                              delim = ": ",
                              names = c("type",
                                "chem_type"),
                           too_many = "merge",
                            too_few = "align_start")

  survey_d_fert <- survey_d_fert |> 
    rename(chem_name = chem_type)
  
  survey_d_fert$chem_name <- str_replace(survey_d_fert$chem_name, "^\\(", "")
  
   survey_d_fert$chem_name <- str_replace(survey_d_fert$chem_name, "\\)$", "")
   
   survey_d_fert <- survey_d_fert |> drop_one_value_col()
  

```

```{r}
#| label: final filters 1
#| echo: false

survey_d_total_ca <- survey_d_total |> 
  filter(State == "CALIFORNIA")

ca_tab <- survey_d_total_ca |> group_by(Year, Period
                                        )
ca_tab_22 <- survey_d_total_ca |> filter(Year == 2022)

ca_tab_22 <- ca_tab_22 |> drop_one_value_col()

ca_tab_22 <- ca_tab_22 |> 
  filter(Period == "YEAR")

ca_tab_22 <- ca_tab_22 |> 
  filter(Value != "(D)")

ca_tab_22 <- ca_tab_22 |> drop_one_value_col()

```

## Chemicals usd in strawberry cultivaion

### Six deadly carcinogens from WHO list

[captafol](https://en.wikipedia.org/wiki/Captafol)

[ethylene dibromide](https://en.wikipedia.org/wiki/1,2-Dibromoethane) [also](https://www.epa.gov/sites/default/files/2016-09/documents/ethylene-dibromide.pdf)

[glyphosate](https://en.wikipedia.org/wiki/Glyphosate) See also [1](https://www.ewg.org/areas-focus/toxic-chemicals/glyphosate)\
[2](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9101768/)\
[3](http://npic.orst.edu/factsheets/glyphogen.html)\
[4](https://www.epa.gov/ingredients-used-pesticide-products/glyphosate)

[malathion](https://en.wikipedia.org/wiki/Malathion) [1](https://www.epa.gov/mosquitocontrol/malathion) [2](http://npic.orst.edu/factsheets/malagen.html)

[diazinon](https://en.wikipedia.org/wiki/Diazinon) [1](https://wwwn.cdc.gov/TSP/PHS/PHS.aspx?phsid=511&toxid=90#:~:text=Diazinon%20is%20the%20common%20name,Dazzel%2C%20Gardentox%2C%20and%20Knoxout.) [2](http://npic.orst.edu/factsheets/Diazgen.html) [3](https://earthjustice.org/feature/organophosphate-pesticides-united-states/diazinon)

[dichlorophenyltrichloroethane (DDT)](https://en.wikipedia.org/wiki/DDT) [1](https://www.acs.org/molecule-of-the-week/archive/d/dichlorodiphenyltrichloroethane.html) [2](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1240724/) \[3\](https://www.epa.gov/ingredients-used-pesticide-products/ddt-brief-history-and-status#:\~:text=DDT%20(dichloro%2Ddiphenyl%2Dtrichloroethane,both%20military%20and%20civilian%20populations.)

### For contrast

[Azadirachtin](https://en.wikipedia.org/wiki/Azadirachtin) [1](https://pubchem.ncbi.nlm.nih.gov/compound/Azadirachtin#section=2D-Structure) [2](https://www.acs.org/molecule-of-the-week/archive/a/azadirachtin.html#:~:text=Azadirachtin%20is%20an%20impressive%20molecule,and%20four%20carboxylic%20acid%20esters.) [3](http://npic.orst.edu/factsheets/neemgen.html)

### Sources of agricultural chemical information

for EPA number lookup [epa numbers](https://archive.epa.gov/pesticides/chemicalsearch/chemical/foia/web/html/128810.html)

[Active Pesticide Product Registration Informational Listing](https://ordspub.epa.gov/ords/pesticides/f?p=APPRIL_PUBLIC:2::::::)

[CAS for Methyl Bromide](https://ordspub.epa.gov/ords/pesticides/f?p=113:17::::::)

[pesticide chemical search](https://ordspub.epa.gov/ords/pesticides/f?p=chemicalsearch:1)

[toxic chemical dashboard](https://comptox.epa.gov/dashboard/)

[pubChem](https://pubchem.ncbi.nlm.nih.gov/)

The EPA PC (Pesticide Chemical) Code is a unique chemical code number assigned by the EPA to a particular pesticide active ingredient, inert ingredient or mixture of active ingredients.

Investigating toxic pesticides

[start here with chem PC code](https://ordspub.epa.gov/ords/pesticides/f?p=chemicalsearch:1)

[step 2](https://ordspub.epa.gov/ords/pesticides/f?p=113:1::::RP,17,1::) to get label (with warnings) for products using the chemical

[Pesticide Product and Label System](https://ordspub.epa.gov/ords/pesticides/f?p=113:1::::RP,17,1::)

[Search by Chemical](https://ordspub.epa.gov/ords/pesticides/f?p=113:17::::::)

[CompTox Chemicals Dashboard](https://comptox.epa.gov/dashboard/)

[Active Pesticide Product Registration Informational Listing](https://ordspub.epa.gov/ords/pesticides/f?p=APPRIL_PUBLIC:2::::::)

[OSHA chemical database](https://www.osha.gov/chemicaldata)

[Pesticide Ingredients](http://npic.orst.edu/ingred/)

[NPIC Product Research Online (NPRO)](http://npic.orst.edu/NPRO/)

[Databases for Chemical Information](http://npic.orst.edu/ingred/cheminfo.html)

[Pesticide Active Ingredients](http://npic.orst.edu/ingred/active.html)

[TSCA Chemical Substance Inventory](https://www.epa.gov/tsca-inventory)

[glyphosate](https://ordspub.epa.gov/ords/pesticides/f?p=CHEMICALSEARCH:3::::1,3,31,7,12,25:P3_XCHEMICAL_ID:2478)
